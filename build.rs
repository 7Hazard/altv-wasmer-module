extern crate serde_json;
extern crate reqwest;
extern crate serde;

use serde::Deserialize;
use serde_repr::Deserialize_repr;
use error_chain::error_chain;
use std::fs::File;
use std::io::{Write, Read};
use serde_json::{Value};
use std::collections::{HashMap, BTreeMap};
use std::path::Path;

error_chain! {
     foreign_links {
         Io(std::io::Error);
         HttpRequest(reqwest::Error);
     }
}

#[tokio::main]
async fn main() -> Result<()>
{
    // write build configs for rustflags
    let profile = std::env::var("PROFILE").unwrap();
    match profile.as_str() {
        "debug" => {
            println!("cargo:rustc-flags=-l libucrtd -l libvcruntimed -l libcmtd -l libcpmtd");
        },
        "release" => {
            println!("cargo:rustc-flags=-l libucrt -l libvcruntime -l libcmt -l libcpmt");
        },
        _ => panic!("bad build profile"),
    };
    
    // dl capi json
    let platform_name = "client";
    let json_file_path = format!("target/altv-capi-{}.json", platform_name);
    if !Path::new(json_file_path.as_str()).exists() {
        let url = format!("http://github.com/7Hazard/altv-capi/releases/latest/download/altv-capi-{}.json", platform_name);
        let response = reqwest::get(url.as_str()).await?;
        let content =  response.bytes().await?;
        File::create(json_file_path).expect("couldn't write file")
            .write_all(&content[..])?;
    }
    
    // Make WASM compatible CAPI structs
    {
        let mut output_str = String::from("// AUTOGENERATED

use wasmer_runtime::{types::ValueType, WasmPtr, Array};

");
        let mut json_str = String::new();
        File::open("target/altv-capi-client.json").expect("could not open file")
            .read_to_string(&mut json_str).expect("could not read to string");
        let capi: CAPI = serde_json::from_str(json_str.as_str()).expect("could not parse json");
        
        // structs
        for (name, s) in capi.structs {
            let struct_name = format!("Wasm_{}", name);
            
            let mut dummy_counter = 0;
            let mut fields = String::new();
            for field in s.fields {
                fields.push_str(field.rust_str(&mut dummy_counter).as_str())
            }
            
            output_str.push_str(format!("#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct {} {{{}\n}}
unsafe impl ValueType for {} {{}}

", struct_name, fields, struct_name).as_str());
        }
        
        // enums
        for (name, e) in capi.enums {
            let enum_name = format!("Wasm_{}", name);
            let mut enumerators_str = String::new();
            for en in e.enumerators {
                enumerators_str.push_str(format!("\n  {} = {},", en.name, en.value).as_str());
            }
            output_str.push_str(format!("#[repr(u8)]
#[derive(Debug, Copy, Clone)]
pub enum {} {{{}\n}}
unsafe impl ValueType for {} {{}}

", enum_name, enumerators_str, enum_name).as_str())
        }
        
        File::create("src/wasm_capi/structs.rs").expect("could not create file")
            .write_all(output_str.as_bytes()).expect("could not write to file")
    }
    
    Ok(())
}

#[derive(Deserialize)]
struct CAPI {
    // BTreeMap instead of HashMap for consistent order of iteration
    structs: BTreeMap<String, Struct>,
    enums: BTreeMap<String, Enum>,
}

#[derive(Deserialize)]
struct Struct {
    fields: Vec<Field>,
}

#[derive(Deserialize)]
struct Field {
    name: String,
    #[serde(rename="type")]
    type_: Type,
}

impl Field {
    fn rust_str(&self, dummy_counter: &mut u8) -> String {
        // get rid of reserved keywords
        let name = match self.name.as_str() {
            "type" => "type_",
            _ => self.name.as_str(),
        };
        
        let ret = format!("\n  pub {}: {},", name, self.type_.rust_str());
        
        match self.type_.kind {
//            TypeKind::Reference | TypeKind::Pointer | TypeKind::Array | TypeKind::FunctionPointer => {
//                ret.push_str(format!("\n  ptr_padding_{}: u32,", dummyCounter).as_str());
//                *dummyCounter += 1;
//                ret
//            },
            _ => ret,
        }
    }
}

#[derive(Deserialize)]
struct Type {
    name: String,
    kind: TypeKind,
    pointee: Option<PointeeType>
}

impl Type {
    fn rust_str(&self) -> String {
        let rust_type = |name:&String|{
            String::from(match name.as_str() {
                "_Bool" => "bool",
                "char" => "i8",
                "unsigned char" => "u8",
                "unsigned short" => "u16",
                "int" => "i32",
                "unsigned int" => "u32",
                "unsigned long long" => "u64",
                "float" => "f32",
                _ => panic!(format!("unhandled fundamental type {}", name)),
            })
        };
        let rust_ptr_type = ||{
            let pointee = match &self.pointee {
                None => panic!(format!("pointee null on {}", self.name)),
                Some(val) => val,
            };
            match pointee.kind {
                TypeKind::Fundamental => match pointee.name.as_str() {
                    "void" => String::from("u32"),
                    _ => rust_type(&pointee.name),
                },
                _ => String::from(format!("Wasm_{}", &pointee.name))
            }
        };
        
        match self.kind {
            TypeKind::Fundamental  => rust_type(&self.name),
            TypeKind::Reference | TypeKind::Pointer => format!("WasmPtr<{}>", rust_ptr_type()),
            TypeKind::Array => format!("WasmPtr<{}, Array>", rust_ptr_type()),
            TypeKind::FunctionPointer => panic!("lets fix it"),
            _ => String::from(format!("Wasm_{}", self.name))
        }
    }
}

#[derive(Deserialize_repr)]
#[repr(u8)]
enum TypeKind {
    Fundamental = 0,
    Enumeral = 1,
    Reference = 2,
    Pointer = 3,
    Array = 4,
    FunctionPointer = 5,
    Struct = 6,
}

#[derive(Deserialize)]
struct PointeeType {
    pub name: String,
    pub kind: TypeKind,
}

#[derive(Deserialize)]
struct Enum {
    enumerators: Vec<Enumerator>
}

#[derive(Deserialize)]
struct Enumerator {
    pub name: String,
    pub value: u8,
}
