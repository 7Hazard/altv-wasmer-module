extern crate serde_json;
extern crate reqwest;
extern crate serde;
extern crate once_cell;

use serde::Deserialize;
use serde_repr::Deserialize_repr;
use error_chain::error_chain;
use std::fs::File;
use std::io::{Write, Read};
use serde_json::Value;
use std::collections::{HashMap, BTreeMap};
use std::path::Path;
use once_cell::unsync::Lazy;
use once_cell::sync::OnceCell;

error_chain! {
     foreign_links {
         Io(std::io::Error);
         HttpRequest(reqwest::Error);
     }
}

#[tokio::main]
async fn main() -> Result<()>
{
  // write build configs for rustflags
  let profile = std::env::var("PROFILE").unwrap();
  match profile.as_str() {
    "debug" => {
      println!("cargo:rustc-flags=-l libucrtd -l libvcruntimed -l libcmtd -l libcpmtd");
    }
    "release" => {
      println!("cargo:rustc-flags=-l libucrt -l libvcruntime -l libcmt -l libcpmt");
    }
    _ => panic!("bad build profile"),
  };

  // dl capi json
  let platform_name = "client";
  let json_file_path = format!("target/altv-capi-{}.json", platform_name);
  if !Path::new(json_file_path.as_str()).exists() {
    let url = format!("http://github.com/7Hazard/altv-capi/releases/latest/download/altv-capi-{}.json", platform_name);
    let response = reqwest::get(url.as_str()).await?;
    let content = response.bytes().await?;
    File::create(json_file_path).expect("couldn't write file")
      .write_all(&content[..])?;
  }

  // Make WASM compatible CAPI structs
  gen_wasm_capi();

  Ok(())
}

static CAPI: OnceCell<CAPI> = OnceCell::new();

fn gen_wasm_capi() {
  let capi = CAPI.get_or_init(||{
    let mut json_str = String::new();
    File::open("target/altv-capi-client.json").expect("could not open file")
      .read_to_string(&mut json_str).expect("could not read to string");
    serde_json::from_str(json_str.as_str()).expect("could not parse json")
  });
  
  let mut output_str = String::from("// AUTOGENERATED

use wasmer_runtime::{types::ValueType, WasmPtr, Array, Ctx};
use altv_capi;
use crate::wasm_pointers::WasmPtrExtentions;
use crate::wasm_pointers::WasmPtrArrayExtentions;

");

  // structs
  for (name, s) in &capi.structs {
    // skip matricies for now
//    if(name.starts_with("alt_Matrix")) {continue};
//    if(name.starts_with("alt_Vector")) {continue};
    
    let is_virtual_struct = is_type_virtual(name); // (|| {
//      &s.fields[0].name == "vtable"
//    })();
    
    let mut extra_args = String::new();
    let mut struct_fields = String::new();
    let mut recon_fields = String::new();
    let mut recon_fields_names = String::new();
    let mut imp = String::new();
    if name.starts_with("alt_Array")
    {
      let data_type: String = (||{
        for field in &s.fields {
          if field.name == "data" { return rust_type(&field.type_.pointee.as_ref().unwrap().name) }
        }
        panic!("couldnt get array type")
      })();
      let data_type_capi: String = (||{
        rust_type_prefix(&s.fields[0].type_.pointee.as_ref().unwrap().name, String::from("altv_capi::"))
      })();
      let data_field = (||{
        let kind = &s.fields[0].type_.pointee.as_ref().unwrap().kind;
        match kind {
          TypeKind::Struct => {
            String::from("
    for i in 0..self.size {
      unsafe { data_array.push((*self.data.mem_index_err(ctx, i as _, err_msg)).reconstruct_err(ctx, err_msg)); }
    }
    let data = data_array.as_mut_ptr();")
          },
          _ => {
            String::from("\n    let data = self.data.mem_err(ctx, err_msg);")
          }
        }
      })();
      struct_fields.push_str(format!("
  pub data: WasmPtr<{}, Array>,
  pub size: u64,
  pub capacity: u64,", data_type).as_str());
      recon_fields.push_str(format!("{}
    let size = self.size;
    let capacity = self.capacity;", data_field).as_str());
      recon_fields_names.push_str("
      data,
      size,
      capacity,");
      extra_args.push_str(format!(", data_array: &mut Vec<{}>", data_type_capi).as_str());
    }
//    else if name.starts_with("alt_Vector") {
//      
//    }
    else {
      let mut dummy_counter = 0;
      for field in &s.fields {
        struct_fields.push_str(field.struct_field(&mut dummy_counter).as_str());
      }
      for field in &s.fields {
        recon_fields.push_str(field.recon_field().as_str());
      }
      for field in &s.fields {
        recon_fields_names.push_str(field.recon_field_names().as_str());
      }
    }

    if (!is_virtual_struct) {
      imp.push_str(format!("
impl {} {{
  pub fn reconstruct_err(&self, ctx: &Ctx, err_msg: &String{}) -> altv_capi::{} {{{}
    altv_capi::{} {{{}
    }}
  }}
}}",
        name, // impl {}
        extra_args,
        name, // altv_capi::{}
        recon_fields, // in reconstruct
        name, recon_fields_names, // altv_capi::{} {{ {} <-
      ).as_str());
    }

    output_str.push_str(format!("#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct {} {{{}\n}}
unsafe impl ValueType for {} {{}}{}

", name, struct_fields, // struct {}
                                name, // ValueType for {}
                                imp,
    ).as_str());
  }

  // enums
  for (name, e) in &capi.enums {
    let enum_name = format!("{}", name);
    let mut enumerators_str = String::new();
    for en in &e.enumerators {
      enumerators_str.push_str(format!("\n  {} = {},", en.name, en.value).as_str());
    }
    output_str.push_str(format!("#[repr(u8)]
#[derive(Debug, Copy, Clone)]
pub enum {} {{{}\n}}
unsafe impl ValueType for {} {{}}

", enum_name, enumerators_str, enum_name).as_str())
  }

  File::create("src/wasm_capi/structs.rs").expect("could not create file")
    .write_all(output_str.as_bytes()).expect("could not write to file")
}

#[derive(Deserialize)]
struct CAPI {
  // BTreeMap instead of HashMap for consistent order of iteration
  structs: BTreeMap<String, Struct>,
  enums: BTreeMap<String, Enum>,
}

#[derive(Deserialize)]
struct Struct {
  fields: Vec<Field>,
}

#[derive(Deserialize)]
struct Field {
  name: String,
  #[serde(rename = "type")]
  type_: Type,
}

impl Field {
  fn struct_field(&self, dummy_counter: &mut u8) -> String {
    // get rid of reserved keywords
    let name = reserved_keyword_clean(&self.name);
    let ret = format!("\n  pub {}: {},", name, self.type_.rust_str());

    match self.type_.kind {
//            TypeKind::Reference | TypeKind::Pointer | TypeKind::Array | TypeKind::FunctionPointer => {
//                ret.push_str(format!("\n  ptr_padding_{}: u32,", dummyCounter).as_str());
//                *dummyCounter += 1;
//                ret
//            },
      _ => ret,
    }
  }
  fn recon_field(&self) -> String {
    // get rid of reserved keywords
    let name = reserved_keyword_clean(&self.name);
    
    let rust_ptr_type = || {
      let pointee = match &self.type_.pointee {
        None => panic!(format!("pointee null on {}", self.name)),
        Some(val) => val,
      };
      match pointee.kind {
        TypeKind::Fundamental => match pointee.name.as_str() {
          "void" => String::from("u32"),
          _ => rust_type(&pointee.name),
        },
        _ => String::from(format!("{}", &pointee.name))
      }
    };

    match self.type_.kind {
      TypeKind::Fundamental => format!("\n    let {} = self.{};", name, name),
      TypeKind::Enumeral => format!("\n   let {} = self.{} as altv_capi::{};", name, name, self.type_.name),
      TypeKind::Struct => format!("\n    let {} = self.{}.reconstruct_err(ctx, err_msg);", name, name),
      TypeKind::Reference | TypeKind::Pointer => {
        if is_type_virtual(&self.type_.pointee.as_ref().unwrap().name) {
          format!("\n    let {} = self.{}.ptr_by_id_err(ctx, err_msg);", name, name)
        } else {
          format!("\n    let {} = self.{}.mem_err(ctx, err_msg);", name, name)
        }
      },
      TypeKind::Array => format!("\n    let {} = self.{}.mem_err(ctx, err_msg) as _;", name, name),
      TypeKind::FunctionPointer => panic!("lets fix it"),
      _ => panic!(format!("unhandled kind {}", self.type_.name))
    }
  }
  fn recon_field_names(&self) -> String {
    format!("\n     {},", reserved_keyword_clean(&self.name))
  }
}

#[derive(Deserialize)]
struct Type {
  name: String,
  kind: TypeKind,
  pointee: Option<PointeeType>,
}

impl Type {
  fn rust_str(&self) -> String {
    let rust_ptr_type = || {
      let pointee = match &self.pointee {
        None => panic!(format!("pointee null on {}", self.name)),
        Some(val) => val,
      };
      match pointee.kind {
        TypeKind::Fundamental => match pointee.name.as_str() {
          "void" => String::from("u32"),
          _ => rust_type(&pointee.name),
        },
        _ => String::from(format!("{}", &pointee.name))
      }
    };

    match self.kind {
      TypeKind::Fundamental => rust_type(&self.name),
      TypeKind::Reference | TypeKind::Pointer => format!("WasmPtr<{}>", rust_ptr_type()),
      TypeKind::Array => format!("WasmPtr<{}, Array>", rust_ptr_type()),
      TypeKind::FunctionPointer => panic!("lets fix it"),
      _ => String::from(format!("{}", self.name))
    }
  }
}

#[derive(Deserialize_repr)]
#[repr(u8)]
enum TypeKind {
  Fundamental = 0,
  Enumeral = 1,
  Reference = 2,
  Pointer = 3,
  Array = 4,
  FunctionPointer = 5,
  Struct = 6,
}

#[derive(Deserialize)]
struct PointeeType {
  pub name: String,
  pub kind: TypeKind,
}

#[derive(Deserialize)]
struct Enum {
  enumerators: Vec<Enumerator>
}

#[derive(Deserialize)]
struct Enumerator {
  pub name: String,
  pub value: u8,
}

fn reserved_keyword_clean(name: &String) -> String {
  String::from(match name.as_str() {
    "type" => "type_",
    _ => name.as_str(),
  })
}

fn rust_type(name: &String) -> String { rust_type_prefix(name, String::from("")) }
fn rust_type_prefix(name: &String, prefix: String) -> String {
  let mut set_prefix = false;
  let t = match name.as_str() {
    "_Bool" => "bool",
    "char" => "i8",
    "unsigned char" => "u8",
    "unsigned short" => "u16",
    "int" => "i32",
    "unsigned int" => "u32",
    "unsigned long long" => "u64",
    "float" => "f32",
    _ => {
      set_prefix = true;
      name.as_str()
    },
//    _ => panic!(format!("unhandled fundamental type {}", name)),
  };
  if set_prefix { format!("{}{}", prefix, t) } else { String::from(t) }
}

fn is_type_virtual(name: &String) -> bool
{
  let capi = CAPI.get().expect("couldnt get capi");
  if capi.structs.contains_key(name){
    capi.structs[name].fields[0].name == "vtable"
  } else { false }
}